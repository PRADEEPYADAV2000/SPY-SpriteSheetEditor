<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NERV SPRITE FORGE - Advanced Spritesheet Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Roboto+Mono:wght@300;400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --nerv-orange: #ff6b00;
            --nerv-red: #cc0000;
            --nerv-dark: #0a0a0a;
            --nerv-darker: #050505;
            --nerv-panel: #1a1a1a;
            --nerv-border: #333;
            --nerv-text: #00ff00;
            --nerv-text-dim: #808080;
            --nerv-warning: #ffcc00;
        }

        body {
            font-family: 'Roboto Mono', 'Share Tech Mono', monospace;
            background: var(--nerv-darker);
            color: var(--nerv-text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .grid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(255, 107, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 107, 0, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridScroll 20s linear infinite;
            z-index: 0;
        }

        @keyframes gridScroll {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent 0%, rgba(255, 107, 0, 0.05) 50%, transparent 100%);
            animation: scan 8s linear infinite;
            pointer-events: none;
            z-index: 9999;
        }

        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            border: 2px solid var(--nerv-orange);
            background: var(--nerv-panel);
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            clip-path: polygon(0 0, calc(100% - 30px) 0, 100% 30px, 100% 100%, 0 100%);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--nerv-orange);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .logo {
            font-family: 'Share Tech Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--nerv-orange);
            text-transform: uppercase;
            letter-spacing: 8px;
            text-shadow: 0 0 20px var(--nerv-orange), 0 0 40px var(--nerv-red);
            margin-bottom: 10px;
        }

        .tagline {
            color: var(--nerv-text-dim);
            font-size: 0.9rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .system-info {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--nerv-border);
            font-size: 0.75rem;
            color: var(--nerv-text-dim);
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-panel {
            background: var(--nerv-panel);
            border: 2px solid var(--nerv-orange);
            padding: 20px;
        }

        .panel-title {
            color: var(--nerv-orange);
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--nerv-border);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            display: block;
            color: var(--nerv-text);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .control-input {
            width: 100%;
            background: var(--nerv-dark);
            border: 1px solid var(--nerv-border);
            color: var(--nerv-text);
            padding: 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--nerv-orange);
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.3);
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, var(--nerv-orange), var(--nerv-red));
            border: none;
            color: #fff;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            clip-path: polygon(0 0, calc(100% - 15px) 0, 100% 15px, 100% 100%, 0 100%);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 0, 0.5);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #333, #555);
            margin-top: 10px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upload-zone {
            background: var(--nerv-panel);
            border: 2px dashed var(--nerv-border);
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            margin-bottom: 20px;
        }

        .upload-zone:hover {
            border-color: var(--nerv-orange);
            background: rgba(255, 107, 0, 0.05);
        }

        .upload-zone.dragover {
            border-color: var(--nerv-orange);
            background: rgba(255, 107, 0, 0.1);
            border-style: solid;
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px var(--nerv-orange));
        }

        .upload-text {
            font-size: 1.2rem;
            color: var(--nerv-text);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .upload-subtext {
            color: var(--nerv-text-dim);
            font-size: 0.8rem;
        }

        .preview-area {
            background: var(--nerv-panel);
            border: 2px solid var(--nerv-orange);
            padding: 20px;
            min-height: 600px;
        }

        .images-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .image-item {
            background: var(--nerv-dark);
            border: 1px solid var(--nerv-border);
            padding: 5px;
            text-align: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .image-item:hover {
            border-color: var(--nerv-orange);
            transform: scale(1.05);
        }

        .image-item img {
            width: 100%;
            height: 80px;
            object-fit: contain;
            margin-bottom: 5px;
            image-rendering: pixelated;
        }

        .image-item-name {
            font-size: 0.65rem;
            color: var(--nerv-text-dim);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .image-item-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            background: var(--nerv-red);
            border: none;
            color: #fff;
            width: 20px;
            height: 20px;
            font-size: 0.7rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spritesheet-preview {
            background: var(--nerv-dark);
            border: 1px solid var(--nerv-border);
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .spritesheet-canvas {
            max-width: 100%;
            border: 1px solid var(--nerv-orange);
            image-rendering: pixelated;
            background: repeating-conic-gradient(#1a1a1a 0% 25%, #222 0% 50%) 50% / 20px 20px;
            margin-bottom: 10px;
        }

        .spritesheet-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--nerv-border);
            display: flex;
            justify-content: space-around;
            font-size: 0.8rem;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            color: var(--nerv-text-dim);
            text-transform: uppercase;
            font-size: 0.7rem;
            margin-bottom: 5px;
        }

        .info-value {
            color: var(--nerv-orange);
            font-weight: 700;
            font-size: 1rem;
        }

        .spritesheet-manager {
            background: var(--nerv-panel);
            border: 2px solid var(--nerv-orange);
            padding: 20px;
        }

        .spritesheet-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .spritesheet-card {
            background: var(--nerv-dark);
            border: 1px solid var(--nerv-border);
            padding: 15px;
            position: relative;
            transition: all 0.3s ease;
        }

        .spritesheet-card:hover {
            border-color: var(--nerv-orange);
        }

        .spritesheet-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .spritesheet-card-title {
            color: var(--nerv-text);
            font-weight: 700;
            font-size: 0.9rem;
        }

        .spritesheet-card-actions {
            display: flex;
            gap: 5px;
        }

        .btn-icon {
            background: var(--nerv-orange);
            border: none;
            color: #fff;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .btn-icon:hover {
            background: var(--nerv-red);
            transform: scale(1.1);
        }

        .spritesheet-card-stats {
            font-size: 0.75rem;
            color: var(--nerv-text-dim);
            margin-bottom: 10px;
        }

        .spritesheet-card-preview {
            width: 100%;
            max-height: 150px;
            object-fit: contain;
            border: 1px solid var(--nerv-border);
            background: repeating-conic-gradient(#1a1a1a 0% 25%, #222 0% 50%) 50% / 10px 10px;
        }

        .status-bar {
            background: var(--nerv-panel);
            border: 2px solid var(--nerv-border);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
        }

        .status-text {
            color: var(--nerv-text);
        }

        input[type="file"] {
            display: none;
        }

        select {
            width: 100%;
            background: var(--nerv-dark);
            border: 1px solid var(--nerv-border);
            color: var(--nerv-text);
            padding: 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--nerv-orange);
        }

        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid var(--nerv-orange);
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .alert-box {
            background: rgba(255, 204, 0, 0.1);
            border: 1px solid var(--nerv-warning);
            color: var(--nerv-warning);
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.8rem;
        }

        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .logo {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="grid-background"></div>
    <div class="scanline"></div>

    <div class="container">
        <div class="header">
            <div class="logo">NERV SPRITE FORGE</div>
            <div class="tagline">Advanced Multi-Sheet Generation System v3.0.0</div>
            <div class="system-info">
                <span>STATUS: <span style="color: var(--nerv-text);">OPERATIONAL</span></span>
                <span>SPRITESHEETS: <span id="totalSheets">0</span></span>
                <span>IMAGES: <span id="totalImages">0</span></span>
            </div>
        </div>

        <div class="main-layout">
            <div class="control-panel">
                <div class="panel-title">‚öô Configuration</div>

                <div class="control-group">
                    <label class="control-label">Base Name</label>
                    <input type="text" class="control-input" id="sheetName" value="spritesheet" placeholder="Enter base name...">
                </div>

                <div class="control-group">
                    <label class="control-label">Max Width (px)</label>
                    <input type="number" class="control-input" id="maxWidth" value="2048" min="256" max="8192" step="256">
                </div>

                <div class="control-group">
                    <label class="control-label">Max Height (px)</label>
                    <input type="number" class="control-input" id="maxHeight" value="2048" min="256" max="8192" step="256">
                </div>

                <div class="control-group">
                    <label class="control-label">Padding (px)</label>
                    <input type="number" class="control-input" id="padding" value="2" min="0" max="20">
                </div>

                <div class="control-group">
                    <label class="control-label">Packing Algorithm</label>
                    <select class="control-input" id="algorithm">
                        <option value="maxrects">MaxRects (Best)</option>
                        <option value="shelf">Shelf BF</option>
                        <option value="simple">Simple Grid</option>
                    </select>
                </div>

                <div class="control-group">
                    <label class="control-label">Output Format</label>
                    <select class="control-input" id="outputFormat">
                        <option value="plist">PLIST (XML)</option>
                        <option value="json">JSON (Cocos2d)</option>
                        <option value="json-array">JSON (Array)</option>
                        <option value="css">CSS Sprites</option>
                    </select>
                </div>

                <div class="control-group">
                    <label class="control-label">Sheet Mode</label>
                    <select class="control-input" id="sheetMode">
                        <option value="single">Single Sheet</option>
                        <option value="multiple">Multiple Sheets (Auto-split)</option>
                    </select>
                </div>

                <button class="btn" id="uploadBtn">
                    üìÅ Add Images
                </button>
                <input type="file" id="fileInput" accept="image/png,image/jpg,image/jpeg" multiple>

                <button class="btn btn-secondary" id="clearBtn">
                    üóëÔ∏è Clear All
                </button>

                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--nerv-border);">
                    <button class="btn" id="generateBtn" disabled>
                        ‚ö° Generate Spritesheet
                    </button>
                    <button class="btn btn-secondary" id="downloadAllBtn" disabled>
                        üì¶ Download All (ZIP)
                    </button>
                </div>
            </div>

            <div class="preview-area">
                <div class="panel-title">üì¶ Input Images</div>

                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">‚¨ÜÔ∏è</div>
                    <div class="upload-text">Drop PNG files here</div>
                    <div class="upload-subtext">or click to browse ‚Ä¢ Supports PNG, JPG, JPEG</div>
                </div>

                <div class="images-list" id="imagesList"></div>

                <div class="panel-title" style="margin-top: 30px;">üñºÔ∏è Preview</div>
                <div id="previewContainer"></div>
            </div>
        </div>

        <div class="spritesheet-manager">
            <div class="panel-title">üìä Generated Spritesheets</div>
            <div class="spritesheet-list" id="spritesheetList">
                <div style="text-align: center; color: var(--nerv-text-dim); padding: 40px; grid-column: 1/-1;">
                    No spritesheets generated yet
                </div>
            </div>
        </div>

        <div class="status-bar" style="margin-top: 20px;">
            <span class="status-text" id="statusText">Ready to generate spritesheets</span>
            <span style="color: var(--nerv-text-dim);">NERV SPRITE FORGE ¬© 2025</span>
        </div>
    </div>

    <script>
        const state = {
            images: [],
            spritesheets: []
        };

        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const imagesList = document.getElementById('imagesList');
        const generateBtn = document.getElementById('generateBtn');
        const clearBtn = document.getElementById('clearBtn');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const statusText = document.getElementById('statusText');
        const previewContainer = document.getElementById('previewContainer');

        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', handleDragOver);
        uploadZone.addEventListener('dragleave', handleDragLeave);
        uploadZone.addEventListener('drop', handleDrop);
        generateBtn.addEventListener('click', generateSpritesheets);
        clearBtn.addEventListener('click', clearAll);
        downloadAllBtn.addEventListener('click', downloadAll);

        // Update button text based on mode
        document.getElementById('sheetMode').addEventListener('change', (e) => {
            if (e.target.value === 'single') {
                generateBtn.textContent = '‚ö° Generate Spritesheet';
            } else {
                generateBtn.textContent = '‚ö° Generate Spritesheets';
            }
        });

        function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            loadImages(files);
            fileInput.value = '';
        }

        function handleDragOver(e) {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        }

        function handleDragLeave(e) {
            uploadZone.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(f =>
                f.type.startsWith('image/') || f.name.match(/\.(png|jpe?g)$/i)
            );
            loadImages(files);
        }

        async function loadImages(files) {
            for (const file of files) {
                const img = await loadImage(file);
                state.images.push({
                    name: file.name,
                    img: img,
                    width: img.width,
                    height: img.height
                });
            }
            renderImagesList();
            updateUI();
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function renderImagesList() {
            if (state.images.length === 0) {
                imagesList.innerHTML = '';
                return;
            }

            imagesList.innerHTML = state.images.map((img, index) => `
                <div class="image-item">
                    <button class="image-item-remove" onclick="removeImage(${index})">√ó</button>
                    <img src="${img.img.src}" alt="${img.name}">
                    <div class="image-item-name">${img.name}</div>
                </div>
            `).join('');
        }

        function removeImage(index) {
            state.images.splice(index, 1);
            renderImagesList();
            updateUI();
        }

        function clearAll() {
            state.images = [];
            state.spritesheets = [];
            renderImagesList();
            renderSpritesheetManager();
            updateUI();
            previewContainer.innerHTML = '';
        }

        function updateUI() {
            const hasImages = state.images.length > 0;
            generateBtn.disabled = !hasImages;
            downloadAllBtn.disabled = state.spritesheets.length === 0;
            document.getElementById('totalImages').textContent = state.images.length;
            document.getElementById('totalSheets').textContent = state.spritesheets.length;

            if (hasImages) {
                statusText.textContent = `${state.images.length} images loaded - Ready to generate`;
            } else {
                statusText.textContent = 'Ready to generate spritesheets';
            }
        }

        function generateSpritesheets() {
            if (state.images.length === 0) return;

            statusText.innerHTML = '<span class="loading"></span> Generating spritesheets...';
            generateBtn.disabled = true;

            setTimeout(() => {
                const maxWidth = parseInt(document.getElementById('maxWidth').value);
                const maxHeight = parseInt(document.getElementById('maxHeight').value);
                const padding = parseInt(document.getElementById('padding').value);
                const algorithm = document.getElementById('algorithm').value;
                const baseName = document.getElementById('sheetName').value || 'spritesheet';
                const sheetMode = document.getElementById('sheetMode').value;

                let sheets;
                if (sheetMode === 'single') {
                    // Single sheet mode - try to fit everything in one sheet
                    sheets = generateSingleSheet(state.images, maxWidth, maxHeight, padding, algorithm, baseName);
                } else {
                    // Multiple sheets mode - auto-split
                    sheets = generateMultipleSheets(state.images, maxWidth, maxHeight, padding, algorithm, baseName);
                }

                if (!sheets || sheets.length === 0) {
                    statusText.textContent = '‚ùå Failed to generate spritesheets';
                    generateBtn.disabled = false;
                    return;
                }

                state.spritesheets = sheets;
                renderPreviews(sheets);
                renderSpritesheetManager();
                updateUI();

                statusText.textContent = `‚úì Generated ${sheets.length} spritesheet${sheets.length > 1 ? 's' : ''} successfully`;
                generateBtn.disabled = false;
            }, 100);
        }

        function generateSingleSheet(images, maxWidth, maxHeight, padding, algorithm, baseName) {
            const packed = packSprites(images, maxWidth, maxHeight, padding, algorithm);

            if (!packed || packed.sprites.length === 0) {
                return null;
            }

            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = packed.width;
            canvas.height = packed.height;
            const ctx = canvas.getContext('2d');

            packed.sprites.forEach(sprite => {
                ctx.drawImage(sprite.img, sprite.x, sprite.y, sprite.width, sprite.height);
            });

            const sheet = {
                id: Date.now(),
                name: baseName,
                canvas: canvas,
                data: packed,
                timestamp: new Date().toLocaleString()
            };

            // Warn if not all images fit
            if (packed.sprites.length < images.length) {
                statusText.innerHTML = `<span style="color: var(--nerv-warning);">‚ö† Only ${packed.sprites.length}/${images.length} images fit in single sheet!</span>`;
            }

            return [sheet];
        }

        function generateMultipleSheets(images, maxWidth, maxHeight, padding, algorithm, baseName) {
            const sheets = [];
            let remainingImages = [...images];
            let sheetIndex = 1;

            while (remainingImages.length > 0) {
                const packed = packSprites(remainingImages, maxWidth, maxHeight, padding, algorithm);

                if (!packed || packed.sprites.length === 0) {
                    // If we can't fit any more, break
                    if (sheets.length === 0) {
                        return null; // Failed to pack any sprites
                    }
                    break;
                }

                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = packed.width;
                canvas.height = packed.height;
                const ctx = canvas.getContext('2d');

                packed.sprites.forEach(sprite => {
                    ctx.drawImage(sprite.img, sprite.x, sprite.y, sprite.width, sprite.height);
                });

                // Format sheet name with leading zeros: sheet_01, sheet_02, etc.
                const paddedIndex = String(sheetIndex).padStart(2, '0');
                const sheetName = `${baseName}_${paddedIndex}`;

                sheets.push({
                    id: Date.now() + sheetIndex,
                    name: sheetName,
                    canvas: canvas,
                    data: packed,
                    timestamp: new Date().toLocaleString()
                });

                // Remove packed sprites from remaining
                const packedNames = new Set(packed.sprites.map(s => s.name));
                remainingImages = remainingImages.filter(img => !packedNames.has(img.name));
                sheetIndex++;
            }

            return sheets;
        }

        function packSprites(images, maxWidth, maxHeight, padding, algorithm) {
            if (algorithm === 'maxrects') {
                return packMaxRects(images, maxWidth, maxHeight, padding);
            } else if (algorithm === 'shelf') {
                return packShelf(images, maxWidth, maxHeight, padding);
            } else {
                return packSimple(images, maxWidth, maxHeight, padding);
            }
        }

        function packMaxRects(images, maxWidth, maxHeight, padding) {
            const sorted = [...images].sort((a, b) => b.height - a.height);
            const freeRects = [{x: 0, y: 0, width: maxWidth, height: maxHeight}];
            const packed = [];

            for (const img of sorted) {
                const w = img.width + padding * 2;
                const h = img.height + padding * 2;

                let bestRect = null;
                let bestScore = Infinity;

                for (const rect of freeRects) {
                    if (rect.width >= w && rect.height >= h) {
                        const score = Math.min(rect.width - w, rect.height - h);
                        if (score < bestScore) {
                            bestScore = score;
                            bestRect = rect;
                        }
                    }
                }

                if (!bestRect) break; // Can't fit more

                packed.push({
                    name: img.name,
                    img: img.img,
                    x: bestRect.x + padding,
                    y: bestRect.y + padding,
                    width: img.width,
                    height: img.height
                });

                const newRects = [];
                if (bestRect.width > w) {
                    newRects.push({
                        x: bestRect.x + w,
                        y: bestRect.y,
                        width: bestRect.width - w,
                        height: bestRect.height
                    });
                }
                if (bestRect.height > h) {
                    newRects.push({
                        x: bestRect.x,
                        y: bestRect.y + h,
                        width: w,
                        height: bestRect.height - h
                    });
                }

                freeRects.splice(freeRects.indexOf(bestRect), 1, ...newRects);
            }

            if (packed.length === 0) return null;

            let actualWidth = 0, actualHeight = 0;
            packed.forEach(sprite => {
                actualWidth = Math.max(actualWidth, sprite.x + sprite.width + padding);
                actualHeight = Math.max(actualHeight, sprite.y + sprite.height + padding);
            });

            return {
                width: actualWidth,
                height: actualHeight,
                sprites: packed
            };
        }

        function packShelf(images, maxWidth, maxHeight, padding) {
            const sorted = [...images].sort((a, b) => b.height - a.height);
            const packed = [];

            let x = padding;
            let y = padding;
            let rowHeight = 0;

            for (const img of sorted) {
                const w = img.width + padding * 2;
                const h = img.height + padding * 2;

                if (x + w > maxWidth) {
                    x = padding;
                    y += rowHeight;
                    rowHeight = 0;
                }

                if (y + h > maxHeight) break;

                packed.push({
                    name: img.name,
                    img: img.img,
                    x: x + padding,
                    y: y + padding,
                    width: img.width,
                    height: img.height
                });

                x += w;
                rowHeight = Math.max(rowHeight, h);
            }

            if (packed.length === 0) return null;

            return {
                width: maxWidth,
                height: y + rowHeight,
                sprites: packed
            };
        }

        function packSimple(images, maxWidth, maxHeight, padding) {
            const packed = [];
            let x = padding;
            let y = padding;
            let rowHeight = 0;

            for (const img of images) {
                const w = img.width + padding * 2;
                const h = img.height + padding * 2;

                if (x + w > maxWidth) {
                    x = padding;
                    y += rowHeight;
                    rowHeight = 0;
                }

                if (y + h > maxHeight) break;

                packed.push({
                    name: img.name,
                    img: img.img,
                    x: x + padding,
                    y: y + padding,
                    width: img.width,
                    height: img.height
                });

                x += w;
                rowHeight = Math.max(rowHeight, h);
            }

            if (packed.length === 0) return null;

            return {
                width: maxWidth,
                height: y + rowHeight,
                sprites: packed
            };
        }

        function renderPreviews(sheets) {
            previewContainer.innerHTML = sheets.map((sheet, index) => {
                const efficiency = calculateEfficiency(sheet.data);
                return `
                    <div class="spritesheet-preview">
                        <canvas class="spritesheet-canvas" width="${sheet.data.width}" height="${sheet.data.height}" id="preview-${index}"></canvas>
                        <div class="spritesheet-info">
                            <div class="info-item">
                                <div class="info-label">Sheet ${index + 1}</div>
                                <div class="info-value">${sheet.name}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Dimensions</div>
                                <div class="info-value">${sheet.data.width} √ó ${sheet.data.height}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Sprites</div>
                                <div class="info-value">${sheet.data.sprites.length}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">Efficiency</div>
                                <div class="info-value">${efficiency}%</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Draw canvases
            sheets.forEach((sheet, index) => {
                const canvas = document.getElementById(`preview-${index}`);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(sheet.canvas, 0, 0);
            });
        }

        function calculateEfficiency(packed) {
            const totalArea = packed.width * packed.height;
            let usedArea = 0;
            packed.sprites.forEach(s => usedArea += s.width * s.height);
            return Math.round((usedArea / totalArea) * 100);
        }

        function renderSpritesheetManager() {
            const list = document.getElementById('spritesheetList');

            if (state.spritesheets.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: var(--nerv-text-dim); padding: 40px; grid-column: 1/-1;">No spritesheets generated yet</div>';
                return;
            }

            list.innerHTML = state.spritesheets.map((sheet, index) => `
                <div class="spritesheet-card">
                    <div class="spritesheet-card-header">
                        <div class="spritesheet-card-title">${sheet.name}</div>
                        <div class="spritesheet-card-actions">
                            <button class="btn-icon" onclick="downloadSheet(${index})" title="Download Package">üì¶</button>
                            <button class="btn-icon" onclick="removeSheet(${index})" title="Remove">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="spritesheet-card-stats">
                        ${sheet.data.width}√ó${sheet.data.height} ‚Ä¢ ${sheet.data.sprites.length} sprites ‚Ä¢ ${sheet.timestamp}
                    </div>
                    <canvas class="spritesheet-card-preview" width="${sheet.data.width}" height="${sheet.data.height}" id="card-preview-${index}"></canvas>
                </div>
            `).join('');

            // Draw preview canvases
            state.spritesheets.forEach((sheet, index) => {
                const canvas = document.getElementById(`card-preview-${index}`);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(sheet.canvas, 0, 0);
                }
            });
        }

        async function downloadSheet(index) {
            const sheet = state.spritesheets[index];
            const format = document.getElementById('outputFormat').value;

            const zip = new JSZip();

            // Add PNG
            const pngBlob = await new Promise(resolve => sheet.canvas.toBlob(resolve));
            zip.file(`${sheet.name}.png`, pngBlob);

            // Add data file
            const dataContent = generateDataFile(sheet.data, sheet.name, format);
            const extension = format === 'plist' ? 'plist' : format === 'css' ? 'css' : 'json';
            zip.file(`${sheet.name}.${extension}`, dataContent);

            // Generate and download
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${sheet.name}.zip`;
            a.click();
            URL.revokeObjectURL(url);

            statusText.textContent = `‚úì Downloaded ${sheet.name}.zip`;
        }

        async function downloadAll() {
            const format = document.getElementById('outputFormat').value;
            const zip = new JSZip();

            for (const sheet of state.spritesheets) {
                // Add PNG
                const pngBlob = await new Promise(resolve => sheet.canvas.toBlob(resolve));
                zip.file(`${sheet.name}.png`, pngBlob);

                // Add data file
                const dataContent = generateDataFile(sheet.data, sheet.name, format);
                const extension = format === 'plist' ? 'plist' : format === 'css' ? 'css' : 'json';
                zip.file(`${sheet.name}.${extension}`, dataContent);
            }

            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'spritesheets_all.zip';
            a.click();
            URL.revokeObjectURL(url);

            statusText.textContent = `‚úì Downloaded all ${state.spritesheets.length} spritesheets`;
        }

        function generateDataFile(packed, sheetName, format) {
            if (format === 'plist') {
                return generatePlist(packed, sheetName);
            } else if (format === 'json') {
                return generateJSONCocos2d(packed, sheetName);
            } else if (format === 'json-array') {
                return generateJSONArray(packed);
            } else if (format === 'css') {
                return generateCSS(packed, sheetName);
            }
        }

        function generatePlist(packed, sheetName) {
            let plist = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>frames</key>
    <dict>
`;
            packed.sprites.forEach(sprite => {
                plist += `        <key>${sprite.name}</key>
        <dict>
            <key>frame</key>
            <string>{{${sprite.x},${sprite.y}},{${sprite.width},${sprite.height}}}</string>
            <key>offset</key>
            <string>{0,0}</string>
            <key>rotated</key>
            <false/>
            <key>sourceColorRect</key>
            <string>{{0,0},{${sprite.width},${sprite.height}}}</string>
            <key>sourceSize</key>
            <string>{${sprite.width},${sprite.height}}</string>
        </dict>
`;
            });

            plist += `    </dict>
    <key>metadata</key>
    <dict>
        <key>format</key>
        <integer>2</integer>
        <key>realTextureFileName</key>
        <string>${sheetName}.png</string>
        <key>size</key>
        <string>{${packed.width},${packed.height}}</string>
        <key>textureFileName</key>
        <string>${sheetName}.png</string>
    </dict>
</dict>
</plist>`;
            return plist;
        }

        function generateJSONCocos2d(packed, sheetName) {
            const frames = {};
            packed.sprites.forEach(sprite => {
                frames[sprite.name] = {
                    frame: {x: sprite.x, y: sprite.y, w: sprite.width, h: sprite.height},
                    rotated: false,
                    trimmed: false,
                    spriteSourceSize: {x: 0, y: 0, w: sprite.width, h: sprite.height},
                    sourceSize: {w: sprite.width, h: sprite.height}
                };
            });

            return JSON.stringify({
                frames: frames,
                metadata: {
                    format: 2,
                    size: {w: packed.width, h: packed.height},
                    textureFileName: `${sheetName}.png`
                }
            }, null, 2);
        }

        function generateJSONArray(packed) {
            return JSON.stringify({
                width: packed.width,
                height: packed.height,
                sprites: packed.sprites.map(s => ({
                    name: s.name,
                    x: s.x,
                    y: s.y,
                    width: s.width,
                    height: s.height
                }))
            }, null, 2);
        }

        function generateCSS(packed, sheetName) {
            let css = `.sprite {
    background-image: url('${sheetName}.png');
    background-repeat: no-repeat;
    display: inline-block;
}\n\n`;

            packed.sprites.forEach(sprite => {
                const className = sprite.name.replace(/[^a-zA-Z0-9]/g, '-');
                css += `.sprite-${className} {
    width: ${sprite.width}px;
    height: ${sprite.height}px;
    background-position: -${sprite.x}px -${sprite.y}px;
}\n\n`;
            });

            return css;
        }

        function removeSheet(index) {
            state.spritesheets.splice(index, 1);
            renderSpritesheetManager();
            updateUI();
        }

        updateUI();
    </script>
</body>
</html>
